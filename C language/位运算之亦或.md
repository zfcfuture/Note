### 位运算之亦或

a⊕b = （¬a ∧ b） ∨ （a ∧¬b）

如果a、b两个值不同，则亦或结果为1；如果a、b两个值相同，亦或结果为0

所以亦或运算有以下三个特点：

- 0亦或任何数 = 任何数
- 1亦或任何数 = 任何数取反
- 任何数亦或自己 = 把自己置0

同时异或运算有以下几个用途：

##### 1. 让特定位翻转

```c
// 例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
　　10100001^00000110 = 10100111
```

##### 2. 交换两个元素不使用临时变量

```c
// 例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：
　　a = a^b； 　　//a=10100111
　　b = b^a； 　　//b=10100001
　　a = a^b； 　　//a=00000110
```

##### 3. 在汇编语言中将某变量置零

`xor a, a`

##### 4. 快速判断两个值是否相等：

```c
// 举例1： 判断两个整数a，b是否相等，则可通过下列语句实现：
    
　　return （（a ^ b） == 0）

// 举例2： Linux中最初的ipv6_addr_equal（）函数的实现如下：

　　staTIc inline int ipv6_addr_equal（const struct in6_addr *a1， const struct in6_addr *a2）

　　{

　　return （a1-》s6_addr32［0］ == a2-》s6_addr32［0］ &&

　　a1-》s6_addr32［1］ == a2-》s6_addr32［1］ &&

　　a1-》s6_addr32［2］ == a2-》s6_addr32［2］ &&

　　a1-》s6_addr32［3］ == a2-》s6_addr32［3］）;

　　}

// 可以利用按位异或实现快速比较， 最新的实现已经修改为：

　　staTIc inline int ipv6_addr_equal（const struct in6_addr *a1， const struct in6_addr *a2）

　　{

　　return （（（a1-》s6_addr32［0］ ^ a2-》s6_addr32［0］） |

　　（a1-》s6_addr32［1］ ^ a2-》s6_addr32［1］） |

　　（a1-》s6_addr32［2］ ^ a2-》s6_addr32［2］） |

　　（a1-》s6_addr32［3］ ^ a2-》s6_addr32［3］）） == 0）;

　　}
```

